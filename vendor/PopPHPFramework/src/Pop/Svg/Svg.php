<?php
/**
 * Pop PHP Framework
 *
 * LICENSE
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.TXT.
 * It is also available through the world-wide-web at this URL:
 * http://www.popphp.org/LICENSE.TXT
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to info@popphp.org so we can send you a copy immediately.
 *
 * @category   Pop
 * @package    Pop_Svg
 * @author     Nick Sagona, III <nick@popphp.org>
 * @copyright  Copyright (c) 2009-2012 Moc 10 Media, LLC. (http://www.moc10media.com)
 * @license    http://www.popphp.org/LICENSE.TXT     New BSD License
 */

/**
 * @namespace
 */
namespace Pop\Svg;

use Pop\Color\Color,
    Pop\Color\Rgb,
    Pop\File\File;

/**
 * @category   Pop
 * @package    Pop_Svg
 * @author     Nick Sagona, III <nick@popphp.org>
 * @copyright  Copyright (c) 2009-2012 Moc 10 Media, LLC. (http://www.moc10media.com)
 * @license    http://www.popphp.org/LICENSE.TXT     New BSD License
 * @version    0.9
 */
class Svg extends File
{

    /**
     * Linear horizontal gradient type.
     * @var int
     */
    const HORIZONTAL = 1;

    /**
     * Linear vertical gradient type.
     * @var int
     */
    const VERTICAL = 2;

    /**
     * Radial gradient type.
     * @var int
     */
    const RADIAL = 3;

    /**
     * SVG image resource
     * @var SimpleXMLElement
     */
    protected $_resource = null;

    /**
     * SVG image width
     * @var int
     */
    protected $_width = null;

    /**
     * SVG image height
     * @var int
     */
    protected $_height = null;

    /**
     * SVG image fill color
     * @var mixed
     */
    protected $_fillColor = null;

    /**
     * SVG image background color
     * @var mixed
     */
    protected $_backgroundColor = null;

    /**
     * SVG image stroke color
     * @var mixed
     */
    protected $_strokeColor = null;

    /**
     * SVG image stroke width
     * @var array
     */
    protected $_strokeWidth = null;

    /**
     * Stroke dash length
     * @var int
     */
    protected $_strokeDashLength = null;

    /**
     * Stroke dash gap
     * @var int
     */
    protected $_strokeDashGap = null;

    /**
     * SVG image available gradients
     * @var array
     */
    protected $_gradients = array();

    /**
     * Current gradient to use.
     * @var int
     */
    protected $_curGradient = null;

    /**
     * SVG image available clipping paths
     * @var array
     */
    protected $_clippingPaths = array();

    /**
     * Current clipping path to use.
     * @var int
     */
    protected $_curClippingPath = null;

    /**
     * SVG image color opacity
     * @var float
     */
    protected $_opacity = 1.0;

    /**
     * SVG image units
     * @var string
     */
    protected $_units = null;

    /**
     * Array of allowed file types.
     * @var array
     */
    protected $_allowed = array('svg' => 'image/svg+xml');

    /**
     * Array of allowed units.
     * @var array
     */
    protected $_allowedUnits = array('em', 'ex', 'px', 'pt', 'pc', 'cm', 'mm', 'in', '%');

    /**
     * Constructor
     *
     * Instantiate an SVG image object based on either a pre-existing SVG image
     * file on disk, or a new SVG image file.
     *
     * @param  string     $svg
     * @param  int|string $w
     * @param  int|string $h
     * @param  mixed      $color
     * @throws Exception
     * @return void
     */
    public function __construct($svg, $w = null, $h = null, Pop_Color_Interface $color = null)
    {
        parent::__construct($svg);

        // If SVG image exists, get image info and store in an array.
        if (file_exists($this->fullpath) && ($this->_size > 0)) {
            $this->_resource = new \SimpleXMLElement($svg, null, true);
            $w = $this->_resource->attributes()->width;
            $h = $this->_resource->attributes()->height;
        // If SVG image does not exists, check to make sure the width and height
        // properties of the new SVG image have been passed.
        } else {
            if ((null === $w) || (null === $h)) {
                throw new Exception($this->_lang->__('Error: You must define a width and height for a new image object.'));
            } else {
                $this->_backgroundColor = (null !== $color) ? $color : new Rgb(255, 255, 255);
                $newSvg = "<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"{$w}\" height=\"{$h}\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n    <desc>\n        SVG Image generated by Pop PHP Library\n    </desc>\n</svg>\n";
                $this->_resource = new \SimpleXMLElement($newSvg);
                if (null !== $color) {
                    $rect = $this->_resource->addChild('rect');
                    $rect->addAttribute('x', '0' . $this->_units);
                    $rect->addAttribute('y', '0' . $this->_units);
                    $rect->addAttribute('width', $w);
                    $rect->addAttribute('height', $h);
                    $rect->addAttribute('fill', $color->getRgb(Color::STRING, true));
                }
            }
        }

        if (!is_numeric(substr($w, -1)) && !is_numeric(substr($w, -2, 1))) {
            $unit = substr($w, -2);
            if (in_array($unit, $this->_allowedUnits)) {
                $this->_units = $unit;
            }
            $this->_width = (float)substr($w, 0, -2);
            $this->_height = (float)substr($h, 0, -2);
        } else if (!is_numeric(substr($w, 0, -1)) && (substr($w, 0, -1) == '%')) {
            $this->_units = '%';
            $this->_width = (float)substr($w, 0, -1);
            $this->_height = (float)substr($h, 0, -1);
        } else {
            $this->_width = (float)$w;
            $this->_height = (float)$h;
        }
    }

    /**
     * Get the SVG image width.
     *
     * @return int
     */
    public function getWidth()
    {
        return $this->_width;
    }

    /**
     * Get the SVG image height.
     *
     * @return int
     */
    public function getHeight()
    {
        return $this->_height;
    }

    /**
     * Get the SVG image units.
     *
     * @return string
     */
    public function getUnits()
    {
        return $this->_units;
    }

    /**
     * Set the fill color.
     *
     * @param  mixed $color
     * @return Pop_Svg
     */
    public function setFillColor(Pop_Color_Interface $color = null)
    {
        $this->_curGradient = null;
        $this->_fillColor = $color;
        return $this;
    }

    /**
     * Set the background color.
     *
     * @param  mixed $color
     * @return Pop_Svg
     */
    public function setBackgroundColor(Pop_Color_Interface $color = null)
    {
        $this->_backgroundColor = $color;
        return $this;
    }

    /**
     * Set the stroke color.
     *
     * @param  mixed $color
     * @return Pop_Svg
     */
    public function setStrokeColor(Pop_Color_Interface $color = null)
    {
        $this->_strokeColor = $color;
        return $this;
    }

    /**
     * Set the stroke width.
     *
     * @param  int $wid
     * @param  int $dash_len
     * @param  int $dash_gap
     * @return Pop_Svg
     */
    public function setStrokeWidth($wid = null, $dash_len = null, $dash_gap = null)
    {
        if ((null === $wid) || ($wid == false) || ($wid == 0)) {
            $this->_strokeWidth = null;
            $this->_strokeDashLength = null;
            $this->_strokeDashGap = null;
        } else {
            $this->_strokeWidth = $wid;
            $this->_strokeDashLength = $dash_len;
            $this->_strokeDashGap = $dash_gap;
        }

        return $this;
    }

    /**
     * Set the opacity.
     *
     * @param  float $opac
     * @return Pop_Svg
     */
    public function setOpacity($opac)
    {
        $this->_opacity = $opac;
        return $this;
    }

    /**
     * Add a gradient.
     *
     * @param  mixed $color1
     * @param  mixed $color2
     * @param  int   $type
     * @return Pop_Svg
     */
    public function addGradient(Pop_Color_Interface $color1, Pop_Color_Interface $color2, $type = Svg::HORIZONTAL)
    {
        $this->_curGradient = count($this->_gradients);
        $defs = $this->_resource->addChild('defs');

        switch ($type) {
            case self::HORIZONTAL:
                $grad = $defs->addChild('linearGradient');
                $grad->addAttribute('id', 'grad' . $this->_curGradient);
                $grad->addAttribute('x1', '0%');
                $grad->addAttribute('y1', '0%');
                $grad->addAttribute('x2', '100%');
                $grad->addAttribute('y2', '0%');
                break;
            case self::VERTICAL:
                $grad = $defs->addChild('linearGradient');
                $grad->addAttribute('id', 'grad' . $this->_curGradient);
                $grad->addAttribute('x1', '0%');
                $grad->addAttribute('y1', '0%');
                $grad->addAttribute('x2', '0%');
                $grad->addAttribute('y2', '100%');
                break;
            case self::RADIAL:
                $grad = $defs->addChild('radialGradient');
                $grad->addAttribute('id', 'grad' . $this->_curGradient);
                $grad->addAttribute('cx', '50%');
                $grad->addAttribute('cy', '50%');
                $grad->addAttribute('r', '50%');
                $grad->addAttribute('fx', '50%');
                $grad->addAttribute('fy', '50%');
                break;
        }

        $stop1 = $grad->addChild('stop');
        $stop1->addAttribute('offset', '0%');
        $stop1->addAttribute('style', 'stop-color: ' . $color1->getRgb(Color::STRING, true) . '; stop-opacity: 1;');

        $stop2 = $grad->addChild('stop');
        $stop2->addAttribute('offset', '100%');
        $stop2->addAttribute('style', 'stop-color: ' . $color2->getRgb(Color::STRING, true) . '; stop-opacity: 1;');

        return $this;
    }

    /**
     * Set the gradient to use.
     *
     * @param  int $index
     * @return Pop_Svg
     */
    public function setGradient($index = null)
    {
        if ((null !== $index) && array_key_exists($index, $this->_gradients)) {
            $this->_curGradient = $index;
        } else {
            $this->_curGradient = null;
        }

        return $this;
    }

    /**
     * Add a clipping rectangle.
     *
     * @param  int $x
     * @param  int $y
     * @param  int $w
     * @param  int $h
     * @return Pop_Svg
     */
    public function addClippingRectangle($x, $y, $w, $h = null)
    {
        $this->_curClippingPath = count($this->_clippingPaths);
        $defs = $this->_resource->addChild('defs');

        $clip = $defs->addChild('clipPath');
        $clip->addAttribute('id', 'clip' . $this->_curClippingPath);

        $rect = $clip->addChild('rect');
        $rect->addAttribute('x', $x . $this->_units);
        $rect->addAttribute('y', $y . $this->_units);
        $rect->addAttribute('width', $w . $this->_units);
        $rect->addAttribute('height', ((null === $h) ? $w : $h) . $this->_units);

        return $this;
    }

    /**
     * Add a clipping square.
     *
     * @param  int $x
     * @param  int $y
     * @param  int $w
     * @return Pop_Svg
     */
    public function addClippingSquare($x, $y, $w)
    {
        $this->addClippingRectangle($x, $y, $w);
        return $this;
    }

    /**
     * Add a clipping ellipse.
     *
     * @param  int $x
     * @param  int $y
     * @param  int $w
     * @param  int $h
     * @return Pop_Svg
     */
    public function addClippingEllipse($x, $y, $w, $h = null)
    {
        $this->_curClippingPath = count($this->_clippingPaths);
        $defs = $this->_resource->addChild('defs');

        $clip = $defs->addChild('clipPath');
        $clip->addAttribute('id', 'clip' . $this->_curClippingPath);

        $ellipse = $clip->addChild('ellipse');
        $ellipse->addAttribute('cx', $x . $this->_units);
        $ellipse->addAttribute('cy', $y . $this->_units);
        $ellipse->addAttribute('rx', $w . $this->_units);
        $ellipse->addAttribute('ry', ((null === $h) ? $w : $h) . $this->_units);

        return $this;
    }

    /**
     * Add a clipping circle.
     *
     * @param  int $x
     * @param  int $y
     * @param  int $w
     * @return Pop_Svg
     */
    public function addClippingCircle($x, $y, $w)
    {
        $this->_curClippingPath = count($this->_clippingPaths);
        $defs = $this->_resource->addChild('defs');

        $clip = $defs->addChild('clipPath');
        $clip->addAttribute('id', 'clip' . $this->_curClippingPath);

        $circle = $clip->addChild('circle');
        $circle->addAttribute('cx', $x . $this->_units);
        $circle->addAttribute('cy', $y . $this->_units);
        $circle->addAttribute('r', $w . $this->_units);

        return $this;
    }

    /**
     * Add a clipping polygon.
     *
     * @param  array $points
     * @return Pop_Svg
     */
    public function addClippingPolygon($points)
    {
        $this->_curClippingPath = count($this->_clippingPaths);
        $defs = $this->_resource->addChild('defs');

        $clip = $defs->addChild('clipPath');
        $clip->addAttribute('id', 'clip' . $this->_curClippingPath);

        $formattedPoints = array();
        foreach ($points as $point) {
            $formattedPoints[] = $point['x'] . ',' . $point['y'];
        }

        $poly = $clip->addChild('polygon');
        $poly->addAttribute('points', implode(' ', $formattedPoints));

        return $this;
    }

    /**
     * Set the clipping path to use.
     *
     * @param  int $index
     * @return Pop_Svg
     */
    public function setClippingPath($index = null)
    {
        if ((null !== $index) && array_key_exists($index, $this->_clippingPaths)) {
            $this->_curClippingPath = $index;
        } else {
            $this->_curClippingPath = null;
        }

        return $this;
    }

    /**
     * Create text within the an SVG image object.
     *
     * @param  string     $str
     * @param  int|string $size
     * @param  int|string $x
     * @param  int|string $y
     * @param  string     $font
     * @param  int|string $rotate
     * @param  boolean      $bold
     * @return Pop_Svg
     */
    public function text($str, $size, $x, $y, $font = 'Arial', $rotate = null, $bold = false)
    {
        $text = $this->_resource->addChild('text', $str);
        $text->addAttribute('x', $x . $this->_units);
        $text->addAttribute('y', $y . $this->_units);
        $text->addAttribute('font-size', $size);
        $text->addAttribute('font-family', $font);

        if (null !== $this->_fillColor) {
            $text->addAttribute('fill', $this->_fillColor->getRgb(Color::STRING, true));
            if ($this->_opacity < 1.0) {
                $text->addAttribute('fill-opacity', $this->_opacity);
            }
        }

        if (null !== $rotate) {
            $text->addAttribute('transform', 'rotate(' . $rotate . ' ' . $x . ',' . $y .')');
        }
        if ($bold) {
            $text->addAttribute('font-weight', 'bold');
        }

        return $this;
    }

    /**
     * Method to add a line to the image.
     *
     * @param  int $x1
     * @param  int $y1
     * @param  int $x2
     * @param  int $y2
     * @return void
     */
    public function addLine($x1, $y1, $x2, $y2)
    {
        $line = $this->_resource->addChild('line');
        $line->addAttribute('x1', $x1 . $this->_units);
        $line->addAttribute('y1', $y1 . $this->_units);
        $line->addAttribute('x2', $x2 . $this->_units);
        $line->addAttribute('y2', $y2 . $this->_units);

        $line = $this->_setStyles($line);

        return $this;
    }

    /**
     * Method to add a rectangle to the image.
     *
     * @param  int $x
     * @param  int $y
     * @param  int $w
     * @param  int $h
     * @return void
     */
    public function addRectangle($x, $y, $w, $h = null)
    {
        $rect = $this->_resource->addChild('rect');
        $rect->addAttribute('x', $x . $this->_units);
        $rect->addAttribute('y', $y . $this->_units);
        $rect->addAttribute('width', $w . $this->_units);
        $rect->addAttribute('height', ((null === $h) ? $w : $h) . $this->_units);

        $rect = $this->_setStyles($rect);

        return $this;
    }

    /**
     * Method to add a square to the image.
     *
     * @param  int     $x
     * @param  int     $y
     * @param  int     $w
     * @return Pop_Svg
     */
    public function addSquare($x, $y, $w)
    {
        $this->addRectangle($x, $y, $w, $w);
        return $this;
    }

    /**
     * Method to add an ellipse to the image.
     *
     * @param  int $x
     * @param  int $y
     * @param  int $w
     * @param  int $h
     * @return Pop_Svg
     */
    public function addEllipse($x, $y, $w, $h = null)
    {
        $ellipse = $this->_resource->addChild('ellipse');
        $ellipse->addAttribute('cx', $x . $this->_units);
        $ellipse->addAttribute('cy', $y . $this->_units);
        $ellipse->addAttribute('rx', $w . $this->_units);
        $ellipse->addAttribute('ry', ((null === $h) ? $w : $h) . $this->_units);

        $ellipse = $this->_setStyles($ellipse);

        return $this;
    }

    /**
     * Method to add a circle to the image.
     *
     * @param  int     $x
     * @param  int     $y
     * @param  int     $w
     * @return Pop_Svg
     */
    public function addCircle($x, $y, $w)
    {
        $circle = $this->_resource->addChild('circle');
        $circle->addAttribute('cx', $x . $this->_units);
        $circle->addAttribute('cy', $y . $this->_units);
        $circle->addAttribute('r', $w . $this->_units);

        $circle = $this->_setStyles($circle);

        return $this;
    }

    /**
     * Method to add an arc to the image.
     *
     * @param  int $x
     * @param  int $y
     * @param  int $w
     * @param  int $h
     * @return Pop_Svg
     */
    public function addArc($x, $y, $start, $end, $w, $h = null)
    {
        if (null === $h) {
            $h = $w;
        }

        $sX = round($w * cos($start / 180 * pi()));
        $sY = round($h * sin($start / 180 * pi()));
        $eX = round($w * cos($end / 180 * pi()));
        $eY = round($h * sin($end / 180 * pi()));

        $centerPoint = array('x' => $x, 'y' => $y);
        $startPoint = array('x' => $x + $sX, 'y' => $y + $sY);
        $endPoint = array('x' => $x + $eX, 'y' => $y + $eY);

        $startQuad = $this->_getQuadrant($startPoint, $centerPoint);
        $endQuad = $this->_getQuadrant($endPoint, $centerPoint);

        $corner1 = array('x' => $this->_width, 'y' => $this->_height);
        $corner2 = array('x' => 0, 'y' => $this->_height);
        $corner3 = array('x' => 0, 'y' => 0);
        $corner4 = array('x' => $this->_width, 'y' => 0);

        $polyPoints = array($centerPoint, $startPoint);

        switch ($startQuad) {
            case 1:
                if ($endQuad == 1) {
                    $polyPoints[] = $corner1;
                    $polyPoints[] = array('x' => $endPoint['x'], 'y' => $this->_height);
                } else if ($endQuad == 2) {
                    $polyPoints[] = $corner1;
                    $polyPoints[] = $corner2;
                } else if ($endQuad == 3) {
                    $polyPoints[] = $corner1;
                    $polyPoints[] = $corner2;
                    $polyPoints[] = $corner3;
                } else if ($endQuad == 4) {
                    $polyPoints[] = $corner1;
                    $polyPoints[] = $corner2;
                    $polyPoints[] = $corner3;
                    $polyPoints[] = $corner4;
                }
                break;
            case 2:
                if ($endQuad == 1) {
                    $polyPoints[] = $corner2;
                    $polyPoints[] = $corner3;
                    $polyPoints[] = $corner4;
                    $polyPoints[] = $corner1;
                } else if ($endQuad == 2) {
                    $polyPoints[] = $corner2;
                    $polyPoints[] = array('x' => 0, 'y' => $endPoint['y']);
                } else if ($endQuad == 3) {
                    $polyPoints[] = $corner2;
                    $polyPoints[] = $corner3;
                } else if ($endQuad == 4) {
                    $polyPoints[] = $corner2;
                    $polyPoints[] = $corner3;
                    $polyPoints[] = $corner4;
                }
                break;
            case 3:
                if ($endQuad == 1) {
                    $polyPoints[] = $corner3;
                    $polyPoints[] = $corner4;
                    $polyPoints[] = $corner1;
                } else if ($endQuad == 2) {
                    $polyPoints[] = $corner3;
                    $polyPoints[] = $corner4;
                    $polyPoints[] = $corner1;
                    $polyPoints[] = $corner2;
                } else if ($endQuad == 3) {
                    $polyPoints[] = $corner3;
                    $polyPoints[] = array('x' => $endPoint['x'], 'y' => 0);
                } else if ($endQuad == 4) {
                    $polyPoints[] = $corner3;
                    $polyPoints[] = $corner4;
                }
                break;
            case 4:
                if ($endQuad == 1) {
                    $polyPoints[] = $corner4;
                    $polyPoints[] = $corner1;
                } else if ($endQuad == 2) {
                    $polyPoints[] = $corner4;
                    $polyPoints[] = $corner1;
                    $polyPoints[] = $corner2;
                } else if ($endQuad == 3) {
                    $polyPoints[] = $corner4;
                    $polyPoints[] = $corner1;
                    $polyPoints[] = $corner2;
                    $polyPoints[] = $corner3;
                } else if ($endQuad == 4) {
                    $polyPoints[] = $corner4;
                    $polyPoints[] = array('x' => $this->_width, 'y' => $endPoint['y']);
                }
                break;
        }

        $polyPoints[] = $endPoint;

        $stamp = rand();

        $defs = $this->_resource->addChild('defs');

        $clip = $defs->addChild('clipPath');
        $clip->addAttribute('id', 'polyClip' . $stamp);

        $formattedPoints = array();
        foreach ($polyPoints as $point) {
            $formattedPoints[] = $point['x'] . ',' . $point['y'];
        }
        $poly = $clip->addChild('polygon');
        $poly->addAttribute('points', implode(' ', $formattedPoints));

        $ellipse = $this->_resource->addChild('ellipse');
        $ellipse->addAttribute('style', 'clip-path: url(#polyClip' . $stamp .');');
        $ellipse->addAttribute('cx', $x . $this->_units);
        $ellipse->addAttribute('cy', $y . $this->_units);
        $ellipse->addAttribute('rx', $w . $this->_units);
        $ellipse->addAttribute('ry', ((null === $h) ? $w : $h) . $this->_units);

        $ellipse = $this->_setStyles($ellipse);

        return $this;
    }

    /**
     * Method to add a polygon to the image.
     *
     * @param  array $points
     * @return Pop_Svg
     */
    public function addPolygon($points)
    {
        $formattedPoints = array();
        foreach ($points as $point) {
            $formattedPoints[] = $point['x'] . ',' . $point['y'];
        }
        $poly = $this->_resource->addChild('polygon');
        $poly->addAttribute('points', implode(' ', $formattedPoints));

        $poly = $this->_setStyles($poly);

        return $this;
    }

    /**
     * Method to add a border to the image.
     *
     * @param  int $w
     * @return Pop_Svg
     */
    public function border($w)
    {
        $rect = $this->_resource->addChild('rect');
        $rect->addAttribute('x', '0px');
        $rect->addAttribute('y', '0px');
        $rect->addAttribute('width', $this->_width . $this->_units);
        $rect->addAttribute('height', $this->_height . $this->_units);

        $color = (null !== $this->_strokeColor) ? $this->_strokeColor : new Rgb(0, 0, 0);

        $rect->addAttribute('stroke', $color->getRgb(Color::STRING, true));
        $rect->addAttribute('stroke-width', ($w * 2) . $this->_units);
        if ((null !== $this->_strokeDashLength) && (null !== $this->_strokeDashGap)) {
            $rect->addAttribute('stroke-dasharray', $this->_strokeDashLength . $this->_units . ',' . $this->_strokeDashGap . $this->_units);
        }

        $rect->addAttribute('fill', 'none');

        return $this;
    }

    /**
     * Method to output the SVG image.
     *
     * @param  boolean $download
     * @return void
     */
    public function output($download = false)
    {
        $dom = new \DOMDocument('1.0');
        $dom->preserveWhiteSpace = false;
        $dom->formatOutput = true;
        $dom->loadXML($this->_resource->asXML());

        $this->_output = $dom->saveXML();

        parent::output($download);
    }

    /**
     * Method to set the styles.
     *
     * @param  SimpleXMLElement
     * @return SimpleXMLElement
     */
    protected function _setStyles($obj)
    {
        if (null !== $this->_curClippingPath) {
            $obj->addAttribute('style', 'clip-path: url(#clip' . $this->_curClippingPath .');');
        }

        if (null !== $this->_curGradient) {
            $obj->addAttribute('fill', 'url(#grad' . $this->_curGradient . ')');
        } else if (null !== $this->_fillColor) {
            $obj->addAttribute('fill', $this->_fillColor->getRgb(Color::STRING, true));
            if ($this->_opacity < 1.0) {
                $obj->addAttribute('fill-opacity', $this->_opacity);
            }
        }
        if (null !== $this->_strokeColor) {
            $obj->addAttribute('stroke', $this->_strokeColor->getRgb(Color::STRING, true));
            $obj->addAttribute('stroke-width', ((null !== $this->_strokeWidth) ? $this->_strokeWidth : 1) . $this->_units);
            if ((null !== $this->_strokeDashLength) && (null !== $this->_strokeDashGap)) {
                $obj->addAttribute('stroke-dasharray', $this->_strokeDashLength . $this->_units . ',' . $this->_strokeDashGap . $this->_units);
            }
        }

        return $obj;
    }

    /**
     * Method to calculate which quadrant a point is in.
     *
     * @param  array $point
     * @param  array $center
     * @return int
     */
    protected function _getQuadrant($point, $center)
    {
        $quad = 0;

        if ($point['x'] >= $center['x']) {
            $quad = ($point['y'] <= $center['y']) ? 4 : 1;
        } else {
            $quad = ($point['y'] <= $center['y']) ? 3 : 2;
        }

        return $quad;
    }

}
