<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
    <title>
        Pop PHP Framework : Documentation
    </title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="Pop PHP Framework" />
    <meta name="keywords" content="pop php framework, php, php framework, php library, documentation" />
    <meta name="description" content="This is the Pop PHP Framework documentation." />
    <meta name="robots" content="all" />

    <style type="text/css">
        pre {
            margin: 0 auto 2% auto;
            padding: 2%;
            width: 96%;
            background-color: #f8f8f8;
            border: solid 1px #ccc;
            font-size: 0.825em;
            font-family: monospace, courier;
        }
    </style>
</head>

<body>
    <h1>Pop PHP Framework</h1>
    <h2>Documentation : Record</h2>
    <div id="doc-content">
        <p>
            <a href="index.html"><strong>Home</strong></a>
        </p>
        <p>
            La composante d'enregistrement, comme indiqué dans la vue d'ensemble de la documentation, est un «hybride» de toutes sortes entre les Active Record et les modèles Table Data Gateway. Via une API normalisée, elle peut donner accès à une seule ligne ou enregistrement dans une table de base de données, ou plusieurs lignes ou des dossiers à la fois. L'approche la plus courante est d'écrire une classe enfant qui étend la classe d'enregistrement qui représente une table dans la base de données. Le nom de la classe enfant doit être le nom de la table. En créant simplement

        </p>
<pre>
use Pop\Record\Record;

class Users extends Record { }
</pre>
        <p>
            vous créez une classe qui possède toutes les fonctionnalités du composant d'enregistrement construit dans la classe et sait le nom de la table de base de données à interroger à partir du nom de la classe. Par exemple, se traduit par «des utilisateurs INTO` utilisateurs `ou traduit des DbUsers 'sur` db_users `(CamelCase est automatiquement converti en lower_case_underscore.) De là, vous pouvez affiner la classe enfant qui représente la table avec des propriétés de classe divers tels que :
        </p>
<pre>
// Table prefix, if applicable
protected $prefix = null;

// Primary ID, if applicable, defaults to 'id'
protected $primaryId = 'id';

// Whether the table is auto-incrementing or not
protected $auto = true;

// Whether to use prepared statements or not, defaults to true
protected $usePrepared = true;
</pre>
        <p>
            De là, l'utilisation de base est la suivante:

        </p>
<pre>
use Users;

// Get a single user
$user = Users::findById(1001);
echo $user->name;
echo $user->email;

// Get multiple users
$users = Users::findAll('last_name ASC');
foreach ($users->rows as $user) {
    echo $user->name;
    echo $user->email;
}
</pre>
    </div>
    <div id="doc-footer">
        <p>
            &copy; 2009-2012 <a href="http://www.moc10media.com/">Moc 10 Media, LLC</a>. All Rights Reserved.
        </p>
    </div>
</body>

</html>

